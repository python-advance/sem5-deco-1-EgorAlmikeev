### 2. Анализ работы декоратора deprecated

__Код функции:__
```python
def deprecated(func):
    
    import warnings
    
    
    code = func.__code__
    warnings.warn_explicit(
        func.__name__ + " is deprecated. ",
        category=DeprecationWarning,
        filename=code.co_filename,
        lineno=code.co_firstlineno + 1
    )
    
    return func
```

__Описание работы:__
Функция-декоратор печатает предупреждение о том что декорируемая функция устарела и не рекомендована к использованию. 
Вывод предположительно происходит в поток error stream. При выводе предупреждения печатается также имя функции, строка
в которой она была вызвана, и имя файла, содержащего вызов.

### 3. Момент вывода предупреждения декоратора deprecated

Предупреждение будет выведено в момент декорирования функции. То есть, даже если функция не вызывается, предупреждение все 
равно будет выведено в момент интерпретации строки с декорированием.

__Возможно ли сделать предупреждение для других ситуаций (например, при вызове функции)?__
Думаю что нет, так как процесс декорирования подразумевает выполнение функции-декоратора. Так как код Python интерпретируется 
построково, он фактически имеет точку входа в первой строчке исполняемого файла. Следовательно, если в одной из строчек будет
встречено использование декоратора, то тело декоратора будет немедленно выполнено. Таким образом, предупреждения всегда будут
"выбрасываться" только при исполнении функции декоратора, то есть не в момент вызова декорируемой функции.

### 4. Оптимизация memorized

Начать стоит с того что декоратор не работает должным образом для функций с kwargs аргументами.

__Пример:__
```python
def memorized(func):
  import functools
  cache = {}
  @functools.wraps(func)
  def inner(*args, **kwargs):
    # key = (args, kwargs)
    key = args + tuple(sorted(kwargs.items()))
    if key not in cache:
      cache[key] = func(*args, **kwargs)
      return cache[key]
  return inner


@memorized
def fun(a, b, **kwargs):
  pass


if __name__ == "__main__":
  fun(1, 2, {"a":3})
```

__Вывод:__
```bash
Traceback (most recent call last):
  File "main.py", line 76, in <module>
    fun(1, 2, {"a":3})
  File "main.py", line 60, in inner
    if key not in cache:
TypeError: unhashable type: 'dict'
```

__Варианты оптимизации:__
В текущем варианте ключем является список аргументов функции. Как вариант, можно записывать сумму аргументов, но надо учитывать что:
* от перестановки мест сумма не меняется
* может возникнуть сложность при складывании некоторых аргументов

Для нормальной работы декоратора необходимо запоминать как значения аргументов, так и их последовательность. Отсюда следует что лучшим вариантом является сохранение набора входных аргументов функции в виде массива tuple.
